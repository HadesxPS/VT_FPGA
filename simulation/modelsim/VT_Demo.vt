// Copyright (C) 1991-2013 Altera Corporation
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, Altera MegaCore Function License 
// Agreement, or other applicable license agreement, including, 
// without limitation, that your use is for the sole purpose of 
// programming logic devices manufactured by Altera and sold by 
// Altera or its authorized distributors.  Please refer to the 
// applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench template that is freely editable to  
// suit user's needs .Comments are provided in each section to help the user    
// fill out necessary details.                                                  
// *****************************************************************************
// Generated on "12/13/2018 09:49:08"
                                                                                
// Verilog Test Bench template for design : VT_Demo
// 
// Simulation tool : ModelSim-Altera (Verilog)
// 

`timescale 1 ns/ 1 ps
module VT_Demo_vlg_tst();
// constants                                           
// general purpose registers
reg eachvec;
// test vector input registers
reg clk_in;
reg rxd;
reg sw1;
reg sw2;
reg sw3;
reg sw4;
reg sw5;
reg sw6;
// wires                                               
wire FPGA_LED_Test;
wire L_CE;
wire L_CLK;
wire L_DC;
wire L_DIN;
wire L_RST;
wire [1:0]  da1_a;
wire [7:0]  da1_din;
wire da1_wr;
wire [1:0]  da2_a;
wire [7:0]  da2_din;
wire da2_wr;
wire [1:0]  da3_a;
wire [7:0]  da3_din;
wire da3_wr;
wire [1:0]  da4_a;
wire [7:0]  da4_din;
wire da4_wr;
wire en_gvddn;
wire en_gvddp;
wire en_n14v;
wire en_p14v;
wire en_vgh;
wire en_vgl;
wire [1:0]  mux_1;
wire [1:0]  mux_2;
wire [1:0]  mux_3;
wire [1:0]  mux_4;
wire [1:0]  mux_5;
wire [1:0]  mux_6;
wire [1:0]  mux_7;
wire [1:0]  mux_8;
wire [1:0]  mux_9;
wire [1:0]  mux_10;
wire [1:0]  mux_11;
wire [1:0]  mux_12;
wire [1:0]  mux_13;
wire [1:0]  mux_14;
wire [1:0]  mux_Test1;
wire [1:0]  mux_Test2;
wire mux_en1;
wire mux_en2;
wire mux_en3;
wire mux_en4;
wire mux_en_Test1;
wire mux_en_Test2;
wire txd;

// assign statements (if any)                          
VT_Demo i1 (
// port map - connection between master ports and signals/registers   
	.FPGA_LED_Test(FPGA_LED_Test),
	.L_CE(L_CE),
	.L_CLK(L_CLK),
	.L_DC(L_DC),
	.L_DIN(L_DIN),
	.L_RST(L_RST),
	.clk_in(clk_in),
	.da1_a(da1_a),
	.da1_din(da1_din),
	.da1_wr(da1_wr),
	.da2_a(da2_a),
	.da2_din(da2_din),
	.da2_wr(da2_wr),
	.da3_a(da3_a),
	.da3_din(da3_din),
	.da3_wr(da3_wr),
	.da4_a(da4_a),
	.da4_din(da4_din),
	.da4_wr(da4_wr),
	.en_gvddn(en_gvddn),
	.en_gvddp(en_gvddp),
	.en_n14v(en_n14v),
	.en_p14v(en_p14v),
	.en_vgh(en_vgh),
	.en_vgl(en_vgl),
	.mux_1(mux_1),
	.mux_2(mux_2),
	.mux_3(mux_3),
	.mux_4(mux_4),
	.mux_5(mux_5),
	.mux_6(mux_6),
	.mux_7(mux_7),
	.mux_8(mux_8),
	.mux_9(mux_9),
	.mux_10(mux_10),
	.mux_11(mux_11),
	.mux_12(mux_12),
	.mux_13(mux_13),
	.mux_14(mux_14),
	.mux_Test1(mux_Test1),
	.mux_Test2(mux_Test2),
	.mux_en1(mux_en1),
	.mux_en2(mux_en2),
	.mux_en3(mux_en3),
	.mux_en4(mux_en4),
	.mux_en_Test1(mux_en_Test1),
	.mux_en_Test2(mux_en_Test2),
	.rxd(rxd),
	.sw1(sw1),
	.sw2(sw2),
	.sw3(sw3),
	.sw4(sw4),
	.sw5(sw5),
	.sw6(sw6),
	.txd(txd)
);
initial                                                
begin                                                  
// code that executes only once                        
// insert code here --> begin                               
sw6=0; 
#100
sw6=1;
// --> end                                             
$display("Running testbench");                       
end
                                                    
always                                                 
// optional sensitivity list                           
// @(event1 or event2 or .... eventn)                  
begin                                                  
// code executes for every event on sensitivity list   
// insert code here --> begin                          
clk_in=0;
while(1)
  #18 clk_in = ~clk_in;                                                      
@eachvec;                                              
// --> end                                             
end                                                    
endmodule

